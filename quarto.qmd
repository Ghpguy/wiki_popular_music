---
title: "Billboard Top Ten Analysis (1958 - 2025)"
author: "Paul Harris"
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 2
    code-tools: true
    theme: cosmo
---

# Introduction

This report analyzes the Billboard Top Ten singles dataset, exploring trends in song longevity, peak positions, artist performance, and collaboration networks over time. The analysis leverages Python, pandas, and Plotly for data visualization and lifelines for survival analysis.

## Data Loading and Preprocessing

```{python}
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from lifelines import KaplanMeierFitter
from sklearn.cluster import KMeans
import networkx as nx
import calendar
from pathlib import Path
import re

# Load data
repo_root = Path().resolve()
csv_path = repo_root / "data" / "billboard_data_2025_09.csv"
df = pd.read_csv(csv_path)
df['Top Ten Entry Date'] = pd.to_datetime(df['Top Ten Entry Date'], errors='coerce')
df['Peak Date'] = pd.to_datetime(df['Peak Date'], errors='coerce')
df['Decade'] = (df['Top Ten Entry Date'].dt.year // 10) * 10
df.head()
```

# Song Longevity in the Top Ten

## Overall Distribution

```{python}
print(f"The overall average number of weeks a song spends in the top 10 is {df['Weeks in Top Ten'].mean():.2f} weeks")
fig = px.bar(
  df['Weeks in Top Ten'].value_counts().sort_index().reset_index(),
  x='Weeks in Top Ten',
  y='count',
  text_auto=True,
  title="Overall Distribution of Weeks in Top Ten (Exact Weeks)"
)
fig.show()
```

## By Decade

```{python}
decade_stats = df.groupby('Decade', as_index=False)['Weeks in Top Ten'].mean()
fig = px.bar(
  decade_stats,
  x='Decade',
  y='Weeks in Top Ten',
  text_auto='.2f',
  title="Average Weeks in Top Ten by Decade"
)
fig.show()
```

## By Year

```{python}
trend = df.groupby("Year")["Weeks in Top Ten"].mean().reset_index()
fig = px.line(
  trend,
  x="Year",
  y="Weeks in Top Ten",
  title="Average Weeks in Top Ten Over Time Per Year",
  labels={"Weeks in Top Ten": "Avg Weeks", "Year": "Year"}
)
fig.show()
```

# Peak Positions

## Distribution of Peak Positions

```{python}
fig = px.bar(
  df['Peak'].value_counts().sort_index().reset_index(),
  x='Peak',
  y='count',
  text_auto=True,
  title="Overall Distribution of Peak Positions"
)
fig.show()
```

## Average Peak by Decade

```{python}
decade_stats = df.groupby('Decade', as_index=False)['Peak'].mean()
fig = px.bar(
  decade_stats,
  x='Decade',
  y='Peak',
  text_auto='.2f',
  title="Average Peak Position in Top Ten by Decade"
)
fig.show()
```

## Average Peak by Year

```{python}
trend = df.groupby("Year")["Peak"].mean().reset_index()
fig = px.line(
  trend,
  x="Year",
  y="Peak",
  title="Average Peak Position in Top Ten Over Time Per Year",
  labels={"Peak": "Avg Peak Position", "Year": "Year"}
)
fig.show()
```

# Survival Analysis

## Survival Curve (All Songs)

```{python}
kmf = KaplanMeierFitter()
kmf.fit(df["Weeks in Top Ten"], event_observed=[1]*len(df))
survival_df = kmf.survival_function_.reset_index()
survival_df.columns = ["Weeks in Top Ten", "Probability of Staying"]
fig = px.line(
  survival_df,
  x="Weeks in Top Ten",
  y="Probability of Staying",
  title="Survival Curve of Billboard Top Ten Singles",
  labels={"Weeks in Top Ten": "Weeks in Top Ten", "Probability of Staying": "Probability of Staying in Top Ten"}
)
fig.show()
```

## Survival Curves by Decade

```{python}
fig = go.Figure()
decades = sorted(df['Decade'].dropna().unique())
for decade in decades:
  group = df[df['Decade'] == decade]
  if len(group) == 0:
    continue
  kmf.fit(group["Weeks in Top Ten"], event_observed=[1]*len(group))
  surv = kmf.survival_function_.reset_index()
  surv.columns = ["Weeks in Top Ten", "Probability of Staying"]
  fig.add_trace(
    go.Scatter(
      x=surv["Weeks in Top Ten"],
      y=surv["Probability of Staying"],
      mode="lines",
      name=str(decade),
      line=dict(width=3)
    )
  )
fig.update_layout(
  title="Survival Curves of Billboard Top Ten Singles by Decade",
  xaxis_title="Weeks in Top Ten",
  yaxis_title="Probability of Staying in Top Ten",
  yaxis=dict(range=[0, 1]),
  showlegend=True
)
fig.show()
```

# Longevity by Peak Position

```{python}
longevity_by_peak = df.groupby("Peak")["Weeks in Top Ten"].mean().reset_index()
longevity_by_peak = longevity_by_peak.sort_values("Peak")
fig = px.bar(
  longevity_by_peak,
  x="Peak",
  y="Weeks in Top Ten",
  text="Weeks in Top Ten",
  labels={"Peak": "Peak Position", "Weeks in Top Ten": "Avg Weeks"},
  title="Average Weeks in Top Ten by Peak Position"
)
fig.show()
```

# Number of Entries per Year

```{python}
entries_per_year = df.groupby("Year")["Single Name"].count().reset_index()
entries_per_year.rename(columns={"Single Name": "Count"}, inplace=True)
fig = px.line(
  entries_per_year,
  x="Year",
  y="Count",
  title="Number of Top Ten Entries per Year",
  labels={"Year": "Year", "Count": "Number of Entries"}
)
fig.show()
```

# Top Artists and One-Hit Wonders

## Top 10 Artists by Top Ten Entries

```{python}
top_artists = df["Artist(s)"].value_counts().head(10).reset_index()
top_artists.columns = ["Artist", "Entries"]
fig = px.bar(
  top_artists,
  x="Entries",
  y="Artist",
  orientation="h",
  text="Entries",
  title="Top Artists by Top Ten Entries"
)
fig.show()
```

## One-Hit Wonders

```{python}
artist_song_counts = df.groupby("Artist(s)")["Single Name"].nunique()
one_hit_pct = (artist_song_counts == 1).mean() * 100
print(f"One-hit wonders (Artists that reach the top 10 only once): {one_hit_pct:.1f}% of artists")
```

# Seasonality: Top Ten Entries by Month and Decade

```{python}
df['Month'] = df['Top Ten Entry Date'].dt.month
entries_by_month_decade = df.groupby(['Month', 'Decade'])['Single Name'].count().reset_index()
entries_by_month_decade.rename(columns={"Single Name": "Entries"}, inplace=True)
entries_by_month_decade['Month Name'] = entries_by_month_decade['Month'].apply(lambda x: calendar.month_abbr[x])
fig = px.bar(
  entries_by_month_decade,
  x='Month Name',
  y='Entries',
  color='Decade',
  barmode='group',
  text='Entries',
  title='Top Ten Entries by Month and Decade',
  height=700
)
fig.show()
```

# Song Trajectory: Lag to Peak

```{python}
df["Lag to Peak"] = (df["Peak Date"] - df["Top Ten Entry Date"]).dt.days
lag_data = df["Lag to Peak"].dropna()
fig = px.histogram(
  lag_data,
  nbins=30,
  title="Distribution of Days to Peak Position",
  labels={"value": "Days", "count": "Count"}
)
fig.show()
```

## Top 10 Songs with Greatest Lag to Peak

```{python}
top_lag = df.nlargest(10, "Lag to Peak")[["Single Name", "Artist(s)", "Lag to Peak", "Top Ten Entry Date", "Peak Date"]]
top_lag['Label'] = top_lag["Single Name"] + " – " + top_lag["Artist(s)"]
fig_top_lag = px.bar(
  top_lag,
  x="Lag to Peak",
  y="Label",
  orientation='h',
  text="Lag to Peak",
  hover_data={
    "Lag to Peak": True,
    "Top Ten Entry Date": True,
    "Peak Date": True,
    "Label": False
  },
  title="Top 10 Songs with Greatest Lag to Peak"
)
fig_top_lag.show()
```

# Longest-Running Top Ten Songs

```{python}
longest = df.nlargest(20, "Weeks in Top Ten")[["Single Name", "Artist(s)", "Weeks in Top Ten"]]
longest['Label'] = longest["Single Name"] + " – " + longest["Artist(s)"]
fig_longest = px.bar(
  longest,
  x="Weeks in Top Ten",
  y="Label",
  orientation='h',
  text="Weeks in Top Ten",
  title="Top 20 Longest-Running Top Ten Songs"
)
fig_longest.show()
```

# Clustering Song Trajectories

```{python}
def clustering_plotly(df, k=4):
  features = df[["Lag to Peak", "Weeks in Top Ten", "Peak"]].dropna()
  km = KMeans(n_clusters=k, random_state=42, n_init=10).fit(features)
  df.loc[features.index, "Cluster"] = km.labels_.astype(str)
  fig_scatter = px.scatter(
    df.loc[features.index],
    x="Lag to Peak",
    y="Weeks in Top Ten",
    color="Cluster",
    hover_data=["Peak", "Lag to Peak", "Weeks in Top Ten", "Single Name", "Artist(s)"],
    title="K-means Clustering of Songs",
    height=600
  )
  fig_scatter.show()
clustering_plotly(df, k=4)
```

## Sleeper Hits (Cluster 2)

```{python}
cluster_2_songs = df[df["Cluster"] == "2"][["Single Name", "Artist(s)", "Weeks in Top Ten", "Lag to Peak", "Peak"]]
cluster_2_songs_sorted = cluster_2_songs.sort_values(by=["Peak", "Weeks in Top Ten"], ascending=[True, False])
cluster_2_songs_sorted['Label'] = cluster_2_songs_sorted["Single Name"] + " – " + cluster_2_songs_sorted["Artist(s)"]
fig_cluster2 = px.bar(
  cluster_2_songs_sorted,
  x="Weeks in Top Ten",
  y="Label",
  orientation='h',
  text="Weeks in Top Ten",
  hover_data=["Peak", "Lag to Peak"],
  title="Sleeper Hits (Songs that Peaked Late but Stayed Long)",
  height=800
)
fig_cluster2.show()
```

# Artist Collaboration Networks by Decade

```{python}
frames = []
decade_list = sorted(df['Decade'].dropna().unique())
for decade in decade_list:
  group = df[df['Decade'] == decade]
  G = nx.Graph()
  for artists in group["Artist(s)"].dropna():
    cleaned = re.sub(
      r'\s*(?:&|\bfeat\.?\b|\bfeaturing\b|,|\band\b|\&)\s*',
      ',',
      str(artists),
      flags=re.IGNORECASE
    )
    names = [a.strip() for a in cleaned.split(',') if a.strip()]
    for i in range(len(names)):
      for j in range(i+1, len(names)):
        G.add_edge(names[i], names[j])
  deg = nx.degree_centrality(G)
  top_artists = sorted(deg.items(), key=lambda x: x[1], reverse=True)[:10]
  subG = G.subgraph(dict(top_artists).keys())
  pos = nx.spring_layout(subG, seed=42)
  edge_x, edge_y = [], []
  for edge in subG.edges():
    x0, y0 = pos[edge[0]]
    x1, y1 = pos[edge[1]]
    edge_x += [x0, x1, None]
    edge_y += [y0, y1, None]
  edge_trace = go.Scatter(
    x=edge_x, y=edge_y,
    line=dict(width=1, color='#888'),
    hoverinfo='none',
    mode='lines'
  )
  node_x, node_y, node_text, node_size = [], [], [], []
  for node in subG.nodes():
    x, y = pos[node]
    node_x.append(x)
    node_y.append(y)
    node_text.append(node)
    node_size.append(deg[node]*2000)
  node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers+text',
    hovertext=node_text,
    text=node_text,
    textposition='top center',
    marker=dict(size=node_size, color='lightblue'),
    showlegend=False
  )
  frames.append(go.Frame(data=[edge_trace, node_trace], name=str(decade)))
# Initial figure
fig = go.Figure(
  data=frames[0].data,
  layout=go.Layout(
    title="Top Artist Collaboration Network by Decade",
    width=1000,
    height=1000,
    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    showlegend=False
  ),
  frames=frames
)
fig.show()
```

# Conclusion

This analysis provides a comprehensive overview of trends in the Billboard Top Ten, including song longevity, peak positions, artist performance, and collaboration networks. Further exploration could include genre-based analysis, deeper clustering, or predictive modeling.

jupyter: python3
---
